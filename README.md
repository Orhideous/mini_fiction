# mini_fiction

CMS для чтения и публикации фанфиков.


## tl;dr (для тех, кто в теме)

* `cd mini_fiction`

* `virtualenv --no-site-packages env`

* `. env/bin/activate`

* `make develop`

* `mini_fiction seed`

* `mini_fiction createsuperuser`

* `mini_fiction runserver`


## Быстрый старт (развёртывание минимального окружения для разработки)

* Устанавливаем Python версии 3.4 или новее (ОС не имеет значения)

* Некоторые зависимости собираются из исходников, поэтому нужно подготовить систему (на Ubuntu это можно сделать командой `sudo apt-get install build-essential`, на Windows — установить Visual Studio или MinGW) или установить их из бинарников заранее (scrypt и/или bcrypt, mysqlclient, lxml)

* Скачиваем mini_fiction, выполнив команду `git clone` или просто скачав и распаковав zip-архив, и переходим в консоли в каталог с проектом:

```
cd mini_fiction
```

* Опционально, но желательно, чтобы не мусорить в системе: устанавливаем `virtualenv` и создаём виртуальное окружение, в каталоге с проектом выполнив команду:

```
virtualenv --no-site-packages env
```

* Входим в созданное окружение командой `. env/bin/activate` (*sh) или `.\env\Scripts\activate` (командная строка Windows)

* Устанавливаем проект командой `make develop` (пользователям Windows придётся открыть `Makefile` и перепечатать команды вручную или использовать make из MinGW)

* Инициализируем базу данных (будет создан файл `db.sqlite3`):

```
mini_fiction seed
```

(Примечание: для персонажей требуются картинки, находящиеся по пути `media/characters/{id}.png`; на момент написания этого примечания их предлагается добыть самостоятельно.)

* Создаём учётную запись администратора:

```
mini_fiction createsuperuser
```

* Запускаем сервер для разработки:

```
mini_fiction runserver
```

* Сайт станет доступен по адресу `http://localhost:5000/`. После авторизации доступна админка по адресу `http://localhost:5000/admin/`. Для корректной работы сайта следует создать хотя бы один жанр.


## Развёртывание приближенного к Production окружения (с поиском и прочим)

* Выполняем всё написанное выше

* Дополнительно устанавливаем поисковый движок Sphinx и memcached.
  Если вы хотите использовать отдельный воркер Celery, также поставьте Redis

* Устанавливаем MySQL, создаём пользователя и базу данных для него.
  Обязательно укажите кодировку UTF-8:

```
create database mini_fiction character set utf8;
```

* Устанавливаем новую зависимость:

```
pip install mysqlclient
```

* Создаём файл `local_settings.py` (в нём хранятся локальные настройки, которые нет смысла публиковать) и включаем в нём всё установленное ранее:

```python
from mini_fiction.settings import Development

class Local(Development):
    # Подключаем БД MySQL вместо sqlite3
    DATABASE_ENGINE = 'mysql'
    DATABASE = {
        'host': '127.0.0.1',
        'port': 3306,
        'user': 'fanfics',  # Не забудьте вписать свои данные!
        'passwd': 'fanfics',
        'db': 'mini_fiction',
    }

    # Включаем поиск Sphinx
    SPHINX_DISABLED = False

    # Если хочется запустить отдельный воркер Celery, который будет обновлять индекс Sphinx, то прописываем это
    CELERY_ALWAYS_EAGER = False

    # Для включения капчи на регистрации прописываем это:
    # RECAPTCHA_PUBLIC_KEY = '6Ldcxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
    # RECAPTCHA_PRIVATE_KEY = '6Ldczzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz'
    # NOCAPTCHA = False
```

* Прописываем созданные нами настройки в переменную окружения. Учтите, что созданный вами модуль должен быть доступен для импорта (например, с помощью `export PYTHONPATH=.`):

```
export MINIFICTION_SETTINGS = local_settings.Local
```

* Создаём каталоги для работы Sphinx (вы можете переопределить путь настройкой `SPHINX_ROOT`):

```
mkdir sphinx && mkdir sphinx/binlog
```

* Теперь можно запустить Sphinx. (Примечание: `sphinxconf.sh` просто запускает `mini_fiction sphinxconf`, который генерирует настройки; не забудьте про включение виртуального окружения (при его наличии) и `MINIFICTION_SETTINGS`, иначе что-нибудь пойдёт не так.)

```
searchd --config sphinxconf.sh
```

* Если база данных уже не пустая, а поиск ещё пустой, то загружаем данные в индексы Sphinx:

```
mini_fiction initsphinx
```

* Если вы указали `CELERY_ALWAYS_EAGER = False`, то запускаем воркер Celery, который будет обновлять индекс поиска (тоже в virtualenv при его наличии):

```
celery -A mini_fiction worker --loglevel=INFO
```

Для боевого (production) окружения наследуйте класс с настройками от модуля `mini_fiction.settings.Config` вместо `Development`. Это важно, так как в режиме разработки доступны некоторые средства для удалённого выполнения кода.


## Прикручивание своего дизайна

На момент написания этого файла полноценного движка тем не предоставляется, зато можно переопределять шаблоны Jinja2 и дополнять статику. Делается это с помощью следующих параметров (`local_settings.py`):

* `STATIC_V = 1` — циферка, которая дописывается в конце каждой ссылки на статический файл. Необходима для принудительной чистки кэша браузеров пользователей. Не забывайте её увеличивать после каждого обновления статики (если вы вообще включили её кэширование в настройках вашего веб-сервера).

* `LOCALSTATIC_ROOT = '/path/to/localstatic'` — путь к каталогу с вашей статикой. После добавления данного параметра файлы из этого каталога становятся доступны по пути `http://example.com/localstatic/` и появляется возожность вставлять ссылки в шаблонах через `{{ url_for('localstatic', filename='foo/bar.baz') }}`.

* `LOCALTEMPLATES = '/path/to/templates'` — каталог с шаблонами Jinja2. При добавлении этого параметра любой загружаемый шаблон ищется сперва в указанном вами каталоге, а если он не найден, то берётся шаблон по умолчанию. Скорее всего, вам потребуется лишь создать свой `base.html`, прописав в нём собственные шапку и CSS.

* `FAVICON_URL = '/localstatic/path/to/favicon.ico'` — ссылка на иконку сайта. Может как находиться в localstatic, так и вести на любой другой сайт.

* `RANDOM_LOGOS = [{'endpoint': 'localstatic', 'filename': 'path/to/image.jpg'}]` или `RANDOM_LOGOS = [{'url': 'http://example.com/logo.jpg'}]` — список из картинок, меняющихся в шапке сайта каждый час. При отсутствии их часть шапки с картинкой (и случайными рассказами) скрывается. Элементы списка — словари; при наличии `endpoint` вызывается Flask-функция `url_for` с указанными в словаре аргументами, в противном случае берётся ссылка из ключа `url`.

* `DEFAULT_USERPIC = {...}` — ссылка на пользовательскую аватарку по умолчанию. Тоже словарь; формат аналогичен элементам `RANDOM_LOGOS`.

Можно попробовать поискать архивы и репозитории с готовой конфигурацией всего этого.
